<templateSet group="algorithm">
  <template name="algo_pair" value="static class Pair&lt;K,V&gt; {&#10;    K key;&#10;    V value;&#10;&#10;    Pair(K key, V value) {&#10;        this.key = key;&#10;        this.value = value;&#10;    }&#10;&#10;    public K getKey() {&#10;        return key;&#10;    }&#10;&#10;    public void setKey(K key) {&#10;        this.key = key;&#10;    }&#10;&#10;    public V getValue() {&#10;        return value;&#10;    }&#10;&#10;    public void setValue(V value) {&#10;        this.value = value;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        Pair&lt;?, ?&gt; pair = (Pair&lt;?, ?&gt;) o;&#10;        return Objects.equals(key, pair.key) &amp;&amp;&#10;                Objects.equals(value, pair.value);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(key, value);&#10;    }&#10;}" description="Pair" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_unionset" value="static class UnionSet {&#10;    int[] count;&#10;    int[] rank;&#10;    int[] parent;&#10;&#10;    UnionSet(int n) {&#10;        count = new int[n];&#10;        parent = new int[n];&#10;        rank = new int[n];&#10;&#10;        for (int i = 0; i &lt; n; i++) {&#10;            parent[i] = i;&#10;            count[i] = 1;&#10;            rank[i] = 1;&#10;        }&#10;    }&#10;&#10;    int find(int x) {&#10;        if (x != parent[x]) {&#10;            parent[x] = find(parent[x]);&#10;        }&#10;        return parent[x];&#10;    }&#10;&#10;    void union(int x, int y) {&#10;        x = find(x);&#10;        y = find(y);&#10;&#10;        if (x != y) {&#10;            if (rank[x] &gt; rank[y]) {&#10;                parent[y] = x;&#10;                count[x] += count[y];&#10;            } else {&#10;                parent[x] = y;&#10;                count[y] += count[x];&#10;                if (rank[x] == rank[y]) {&#10;                    ++rank[x];&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" description="UnionSet" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_lowmemscanner" value=" private static class MyScanner {&#10;    BufferedReader br;&#10;&#10;    private MyScanner() {&#10;        br = new BufferedReader(new InputStreamReader(System.in));&#10;    }&#10;&#10;    private boolean isSpace(char c) {&#10;        return c == '\n' || c == '\r' || c == ' ';&#10;    }&#10;&#10;    String next() {&#10;        try {&#10;            StringBuilder sb = new StringBuilder();&#10;            int r;&#10;            while ((r = br.read()) != -1 &amp;&amp; isSpace((char)r));&#10;            if (r == -1) {&#10;                return null;&#10;            }&#10;&#10;            sb.append((char) r);&#10;            while ((r = br.read()) != -1 &amp;&amp; !isSpace((char)r)) {&#10;                sb.append((char)r);&#10;            }&#10;            return sb.toString();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    int nextInt() {&#10;        return Integer.parseInt(next());&#10;    }&#10;&#10;    long nextLong() {&#10;        return Long.parseLong(next());&#10;    }&#10;&#10;    double nextDouble() {&#10;        return Double.parseDouble(next());&#10;    }&#10;}" description="Low memory scanner" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_bit" value="private static class BIT {&#10;    int[] dat;&#10;    int n;&#10;&#10;    BIT(int n) {&#10;        this.n = n;&#10;        this.dat = new int[n + 1];&#10;    }&#10;&#10;    int sum(int i) {&#10;        int s = 0;&#10;        while (i &gt; 0) {&#10;            s += dat[i];&#10;            i -= (i &amp; -i);&#10;        }&#10;        return s;&#10;    }&#10;&#10;    void add(int i, int x) {&#10;        while (i &lt;= n) {&#10;            dat[i] += x;&#10;            i += (i &amp; -i);&#10;        }&#10;    }&#10;}" description="BIT" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_multiset" value="private static class MultiSet&lt;T extends Comparable&lt;T&gt;&gt; {&#10;    private final TreeMap &lt;T, Integer&gt; map;&#10;&#10;    public MultiSet() {&#10;        map = new TreeMap&lt;&gt;();&#10;    }&#10;&#10;    public void add(T x) {&#10;        map.put(x, map.getOrDefault(x, 0) + 1);&#10;    }&#10;&#10;    public void remove(T x) {&#10;        map.put(x, map.getOrDefault(x, 0) - 1);&#10;        if (map.get(x) &lt;= 0) {&#10;            map.remove(x);&#10;        }&#10;    }&#10;&#10;    public T min() {&#10;        return map.firstKey();&#10;    }&#10;&#10;    public T max() {&#10;        return map.lastKey();&#10;    }&#10;&#10;    public boolean isEmpty() {&#10;        return map.isEmpty();&#10;    }&#10;}" description="MultiSet" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_mint" value="private static final int MOD = 1000_000_007;&#10;private long add(long a, long b) { return (((a + b) % MOD + MOD) % MOD);}&#10;private long sub(long a, long b) { return (((a - b) % MOD + MOD) % MOD); }&#10;private long mul(long a, long b) { return (((a * b) % MOD + MOD) % MOD); }&#10;private long div(long a, long b) { return (((a * inv(b)) % MOD + MOD) % MOD); }&#10;private long inv(long a) { return pow(a, MOD - 2); }&#10;private long pow(long a, int n) {&#10;    long ret = 1;&#10;    while (n &gt; 0) {&#10;        if ((n &amp; 1) &gt; 0) { ret = mul(ret, a); }&#10;        a = mul(a, a);&#10;        n &gt;&gt;= 1;&#10;    }&#10;    return ret;&#10;}&#10;" description="Mod int" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_fft" value="public void add(double[] a, double[] b, double[] c) {&#10;    double x = a[0] + b[0];&#10;    double y = a[1] + b[1];&#10;    c[0] = x; c[1] = y;&#10;}&#10;&#10;public void sub(double[] a, double[] b, double[] c) {&#10;    double x = a[0] - b[0];&#10;    double y = a[1] - b[1];&#10;    c[0] = x; c[1] = y;&#10;}&#10;&#10;public void mul(double[] a, double[] b, double[] c) {&#10;    double x = a[0] * b[0] - a[1] * b[1];&#10;    double y = a[0] * b[1] + a[1] * b[0];&#10;    c[0] = x; c[1] = y;&#10;}&#10;&#10;public void set(double[] a, double[] b) {&#10;    a[0] = b[0]; a[1] = b[1];&#10;}&#10;&#10;private void dft(double[][] f, double[][] tmp, int l, int r, int inv, double[] cur, double[] step) {&#10;    int n = r - l;&#10;    if (n == 1) return;&#10;&#10;    int m = (l + r) / 2;&#10;    for (int i = l; i &lt; r; ++i)  set(tmp[i], f[i]);&#10;    for (int i = l, j1 = l, j2 = m; i &lt; r; ++i) {&#10;        if (i % 2 == 0) {&#10;            set(f[j1++], tmp[i]);&#10;        } else {&#10;            set(f[j2++], tmp[i]);&#10;        }&#10;    }&#10;&#10;    dft(f, tmp, l, m, inv, cur, step);&#10;    dft(f, tmp, m, r, inv, cur, step);&#10;&#10;    cur[0] = 1; cur[1] = 0;&#10;    step[0] = Math.cos(Math.PI * 2 / n); step[1] = Math.sin(Math.PI * 2 * inv / n);&#10;    for (int i1 = l, i2 = m; i1 &lt; m; ++i1, ++i2) {&#10;        double[] a = tmp[i1]; set(a, cur); mul(a, f[i2], a); add(f[i1], a, a);&#10;        double[] b = tmp[i2]; set(b, cur); mul(b, f[i2], b); sub(f[i1], b, b);&#10;        mul(cur, step, cur);&#10;    }&#10;&#10;    for (int i = l; i &lt; r; ++i) set(f[i], tmp[i]);&#10;}&#10;&#10;private int[] convolution(int[] a_, int[] b_) {&#10;    int maxLen = Math.max(a_.length, b_.length) &lt;&lt; 1;&#10;    int len = 1; while (len &lt; maxLen) len &lt;&lt;= 1;&#10;    double[][] a = new double[len][2];&#10;    double[][] b = new double[len][2];&#10;    double[][] t = new double[len][2];&#10;&#10;    for (int i = 0; i &lt; a_.length; ++i) a[i][0] = a_[i];&#10;    for (int i = 0; i &lt; b_.length; ++i) b[i][0] = b_[i];&#10;&#10;    dft(a, t,0, len,1, new double[2], new double[2]);&#10;    dft(b, t,0, len,1, new double[2], new double[2]);&#10;&#10;    double[][] c = new double[len][2];&#10;    for (int i = 0; i &lt; len; ++i)  mul(a[i], b[i], c[i]);&#10;&#10;    dft(c, t, 0, len, -1, new double[2], new double[2]);&#10;&#10;    int[] ret = new int[len];&#10;    for (int i = 0; i &lt; len; ++i) ret[i] = (int)(c[i][0] / len + 0.5);&#10;    return ret;&#10;}" description="FFT" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_math" value="long mod(long a, long m) {&#10;    return (a % m + m) % m;&#10;}&#10;&#10;long extGcd(long a, long b, long[] r) {&#10;    long px = 1, x = 0, py = 0, y = 1;&#10;    while (b != 0) {&#10;        long q = a / b;&#10;        long nx = px - q * x; px = x; x = nx;&#10;        long ny = py - q * y; py = y; y = ny;&#10;        long na = b; b = a % b; a = na;&#10;    }&#10;    r[0] = px; r[1] = py;&#10;    return a;&#10;}&#10;&#10;long[] chineseRem(long[] b, long[] m) {&#10;    long r = 0, M = 1;&#10;    int n = b.length;&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        long[] x = new long[2];&#10;        long d = extGcd(M, m[i], x);&#10;        if ((b[i] - r) % d != 0) return new long[] { 0, -1 };&#10;        long y = m[i] / d;&#10;        long t = (b[i] - r) / d * x[0] % y;&#10;        r += M * t;&#10;        M *= y;&#10;    }&#10;    return new long[] { mod(r, M), M };&#10;}" description="Math" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_permutation" value="private void permutation(int k, int[] a) {&#10;    if (k == N) {&#10;        // a is a permutation from 0..k-1&#10;    } else {&#10;        boolean[] vis = new boolean[N];&#10;        for (int i = 0; i &lt; k; ++i) vis[a[i]] = true;&#10;        for (int i = 0; i &lt; N; ++i) {&#10;            if (!vis[i]) {&#10;                a[k] = i;&#10;                permutation(k + 1, a);&#10;            }&#10;        }&#10;    }&#10;}" description="permutation" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="algo_seg" value="private static class Seg {&#10;    long[] data, datb;&#10;    int n;&#10;&#10;    Seg(int m) {&#10;        n = 1;&#10;        while (n &lt; m) n *= 2;&#10;        data = new long[n * 2];&#10;        datb = new long[n * 2];&#10;    }&#10;&#10;    void add(int a, int b, long x) {&#10;        add(a, b, x, 0, 0, n);&#10;    }&#10;&#10;    long sum(int a, int b) {&#10;&#10;        return sum(a, b, 0, 0, n);&#10;    }&#10;&#10;    void add(int a, int b, long x, int k, int l, int r) {&#10;        if (a &lt;= l &amp;&amp; r &lt;= b) {&#10;            data[k] += x;&#10;        } else if (l &lt; b &amp;&amp; a &lt; r) {&#10;            datb[k] += (Math.min(b, r) - Math.max(a, l)) * x;&#10;            add(a, b, x, k * 2 + 1, l, (l+r)/2);&#10;            add(a, b, x, k * 2 + 2, (l+r)/2, r);&#10;        }&#10;    }&#10;&#10;    long sum(int a, int b, int k, int l, int r) {&#10;        if (b &lt;= l || r &lt;= a) {&#10;            return 0;&#10;        } else if (a &lt;= l &amp;&amp; r &lt;= b) {&#10;            return data[k] * (r - l) + datb[k];&#10;        } else {&#10;            long res = (Math.min(b, r) - Math.max(a, l)) * data[k];&#10;            res += sum(a, b, k * 2 + 1, l, (l+r)/2);&#10;            res += sum(a, b, k * 2 + 2, (l+r)/2, r);&#10;            return res;&#10;        }&#10;    }&#10;}" description="Segment Tree" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
</templateSet>